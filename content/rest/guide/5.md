/*
Title: 5.构建数据
Sort: 5
Tmpl : page-guide
*/

## 5.构建数据
构建结构合理的NoSQL存储需要有相当的远见卓识，最重要的是，我们需要理解数据以后是怎样被读取的，如何使这个过程尽可能的简单。

####避免嵌套
由于我们的数据支持嵌套32层，所以会很自然的认为这是默认结构。但是，当我们从数据库中取得一个节点的时候，我们需要检索该节点所有的子节点。在实践中，最好是保证数据的扁平，就像SQL中的表结构一样。思考一下下面的不良结构：
``` json
{

  // 一个不合理的数据结构, 因为遍历rooms得到的名字列表需要下载数百兆字节的数据

  "rooms": {

    "one": {

      "name": "room alpha",

      "type": "private",

      "messages": {

        "m1": { "sender": "mchen", "message": "foo" },

        "m2": { ... },

        // 非常长的消息列表

      }

    }

  }

}

```

这种嵌套的结构设计，使得数据遍历变得非常困难。哪怕是像列出房间的名字这种简单的操作，也需要将包含所有成员和分组的房间树下载到客户端。

####数据扁平化
如果数据被分割成各自不同的路径，就可以高效的下载需要的部分。考虑下面的扁平化结构：
```json
{

  // roooms只包含每个room的元数据，存储在每个唯一标识的room id节点之下

  "rooms": {

    "one": {

      "name": "room alpha",

      "type": "private"

    },

    "two": { ... },

    "three": { ... }

  },

  // room成员易于访问，我们页是按照room id来存储

  "members": {

    // 我们将讨论下面的指数

    "one": {

      "mchen": true,

      "hmadi": true

    },

    "two": { ... },

    "three": { ... }

  },

  // 消息被分开存储，这样我们可以更快的遍历，同时通过room ID我们也可以方便的分页、查询和组织

  "messages": {

    "one": {

      "m1": { "sender": "mchen", "message": "foo" },

      "m2": { ... },

      "m3": { ... }

    },

    "two": { ... },

    "three": { ... }

  }

}

```
现在可以仅仅需要下载每个房间几个字节的数据就可以遍历所有的房间，快速的获取元数据用来在用户界面显示。消息可以分别获取，立即展示，保持用户交互界面的反应速度。

####创建规模数据
在创建应用的过程中，很多时候我们优先选择只下载列表的一个子集，当列表包含数千条记录或者更多时，这种做法更为常见。当数据之间的关系是静态的，单向的时候，我们可以将子节点直接嵌套在其父节点之下：
``` json
{
  "users": {
    "john": {
       "todoList": {
          "rec1": "Walk the dog",
          "rec2": "Buy milk",
          "rec3": "Win a gold medal in the Olympics"
       }
    }
  }
}
```
通常数据之间的关系都是静态的，或者数据有必要是非规范化的。这可以通过查询子集列表来解决，正如我们在前面检索数据章节谈论的那样。

但这样仍然存在不足。例如，用户和分组之间是双向的关系，用户属于一个分组，分组中包含用户的列表。由于两者之间不能互相嵌套，首先想到的数据结构如下：
``` json
// 双向关系

{

  "users": {

    "mchen": { "name": "Mary Chen" },

    "brinchen": { "name": "Byambyn Rinchen" },

    "hmadi": { "name": "Hamadi Madi" }

  },

  "groups": {

    "alpha": {

       "name": "Alpha Tango",

       "members": {

          "m1": "mchen",

          "m2": "brinchen",

          "m3": "hamadi"

       }

    },

    "bravo": { ... },

    "charlie": { ... }

  }

}

```
良好的开始。但是当我们需要指导用户属于那些分组时，事情变得复杂起来。我们可以监控所有的分组，一旦发生变化就遍历一遍，但是这种方式是效率低下的。更糟的情况是，Mary没有查看所有分组的权限。当我们尝试获取所有的分组列表时，会返回一个禁止操作的错误。
一个良好的方式是只查询Mary所属的分组。这时候Mary所属分组的索引旧变得非常有用了：
``` json
// 索引追踪

{
  "users": {

    "mchen": {

      "name": "Mary Chen",

      // 简介中索引Mary的分组信息

      "groups": {

         // 这里的数据不重要，只是key存在

         "alpha": true,

         "charlie": true

      }

    },

    ...

  },

  "groups": { ... }

}

```
我们只能在Mary的记录和分组的记录中重复存储关系数据来解决这个问题吗？现在分组下面有mchen索引，Mary的配置中有alpha，如果要从分组中删除Mary，需要更新两个位置的数据吗？
是的。这是保存双向关系必要的冗余，这可以帮助我们快速高效的获取Mary对应的成员关系，即使是用户和分组的数据量达到百万，即使规则表达式中限制某些记录的读取。
点击这里尝试一个互动的例子，展示使用索引来引用数据清单。
为什么我们要将数据转化为以id作为主键，以`true`作为值呢？因为这样可以使我们仅通过读取`/users/mchen/groups/$group_id`看是否为`null`来检查主键。
